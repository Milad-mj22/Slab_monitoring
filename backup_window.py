# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'eror_window.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys


from PyQt5.QtGui import *
from PyQt5.QtGui import *
from PyQt5.QtGui import *
import cv2
from pyqt5_plugins import *
from PyQt5 import QtCore,QtGui

from PySide6.QtCore import *
from PySide6.QtUiTools import loadUiType
from PySide6.QtWidgets import *
import database
import texts
import detect_lenguage,colors_pallete
import threading
import os, shutil



ui2, _ = loadUiType("backup_window.ui")


class UI_backup_window(QMainWindow, ui2):
    global widgets
    widgets_eror = ui2
    image_glob=0
    close_sign=0
    def __init__(self):
        super(UI_backup_window, self).__init__()
        self.setupUi(self)
        # Remove default frame
        flags = Qt.WindowFlags(Qt.FramelessWindowHint)# | Qt.WindowStaysOnTopHint)
        self.pos_ = self.pos()
        self.setWindowFlags(flags)
        self.activate_()
        self.set_language()
        # self.set_text()
        # self.show()
        self.statusBar = QStatusBar()
        self.setStatusBar(self.statusBar)


        self.toolButton_folder.clicked.connect(self.open_folder_dialog)
        self.selectall_btn.clicked.connect(self.func_select_all)
        self.clearall_btn.clicked.connect(self.func_deselect_all)
        self.selectavailable_btn.clicked.connect(self.func_select_available)
        self.start_btn.clicked.connect(self.start_copy)
        self.cancel_btn.clicked.connect(self.fuc_cancel_copy)

        # self.test()
        self.default_path()
        self.copy_flag=True
#         record=[(124, '0', '1400-12-11', '10:52:12', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/images/New folder\\0'), (123, '0', '1400-12-08', '18:29:32', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/images/New folder\\0'), (122, '0', '1400-12-07', '17:33:05', '0', '1-asd', '0', '0', '0', '0', 'F:/Foolad-slab/img_path\\0_20220226173302'), (121, '0', '1400-12-07', '16:39:18', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/img_path\\0_20220226163915'), (120, '0', '1400-12-07', '16:21:20', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/img_path\\0_20220226162115'), (119, '0', '1400-12-07', '10:21:42', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/img_path\\0_20220226102134'), (118, '0', '1400-12-07', '10:21:28', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/img_path\\0_20220226102118'), 
# (117, '0', '1400-12-05', '11:21:14', '0', 'No Defect', '0', '0', '0', '0', 'F:/assad-slab/img_path\\0'), (116, '8887', '1400-12-05', '08:53:16', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/py_toggle\\8887'), (115, '0', '1400-12-05', '08:53:01', '0', 'No Defect', '0', '0', '0', '0', 'F:/Foolad-slab/py_toggle\\0_20220224085257')]
#         self.set_data(records=record)
#         self.lineEdit_directory.setText('F:/New folder')





        self._old_pos = None


    def set_language(self):
        self.language = detect_lenguage.language()


    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self._old_pos = event.pos()

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self._old_pos = None

    def mouseMoveEvent(self, event):
        if not self._old_pos:
            return
        delta = event.pos() - self._old_pos
        self.move(self.pos() + delta)
     #   sys.exit(app.exec())


    def default_path(self):
        desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop') 
        self.lineEdit_directory.setText(desktop)

    def activate_(self):
        self.close_btn.clicked.connect(self.close_win)
        # self.close_btn_2.clicked.connect(self.close_win)
    def close_win(self):
        self.copy_flag=False
        self.close()


    def open_folder_dialog(self):
        file = str(QFileDialog.getExistingDirectory(self, "Select Directory"))
        self.lineEdit_directory.setText(file)

    def set_data(self,records):
        print(records)

        records=self.prepare_records(records)

        self.hh_Labels=['Slab ID','Status', 'Date', 'Time','Line','Slab Defects', 'Thickness','Weight','Width','Length','Image Path']
        self.table_report.setHorizontalHeaderLabels(self.hh_Labels)
        header = self.table_report.horizontalHeader()       
        header = self.table_report.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeToContents)

        self.table_report.setRowCount(len(records))

        for row,string in enumerate(records):
            for i in range(11):
                print(i)

                table_item = QTableWidgetItem(str(string))
                if i ==0:
                    table_item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)
                    table_item.setCheckState(Qt.CheckState.Unchecked)
                table_item.setData(Qt.DisplayRole, str(string[i+1]))
                if records[row][i+1]=='Available':
                    print('available')
                    # table_item.setForeground(QColor('#357C3C'))
                if records[row][i+1]=='Missing':
                    print('mis')
                    # table_item.setForeground(QColor('#B33030'))
                # table_item.item(2,2).setBackground(QtGui.QColor(0, 204, 0))
                self.table_report.setItem(row,i,table_item)


    def prepare_records(self,records):
        for i in range (len(records)):
            if os.path.exists(records[i][-1]):
                a = list(records[i])
                a.insert(2, 'Available')
                currentQColor = QtCore.Qt.darkGreen
                
                records[i] = tuple(a)
            else:
                a = list(records[i])
                a.insert(2, 'Missing')
                currentQColor = QtCore.Qt.darkGreen
                
                records[i] = tuple(a)                
            # records[i].insert(1,'x')
        return records


    def func_select_all(self):

        # self.table_report.setRowCount(len(records))

        for i in range(self.table_report.rowCount()):
                self.table_report.item(i, 0).setCheckState(Qt.CheckState.Checked)

    def func_deselect_all(self):

        # self.table_report.setRowCount(len(records))

        for i in range(self.table_report.rowCount()):
                self.table_report.item(i, 0).setCheckState(Qt.CheckState.Unchecked)

    def func_select_available(self):
        self.func_deselect_all()
        for i in range(self.table_report.rowCount()):
            if self.table_report.item(i, 1).text()=='Available':
                self.table_report.item(i, 0).setCheckState(Qt.CheckState.Checked)

    def start_copy(self):
        
        try:
            self.parent_dir=self.lineEdit_directory.text()
            print(self.parent_dir)
            if not os.path.exists(self.parent_dir):
                os.mkdir(self.parent_dir)
        except:
            print('path_eror')

            self.show_mesagges(self.label_notif,text=texts.MESSAGES['backup_address_error'][self.language],level=2)

            return

        flag_select=False
        for i in range(self.table_report.rowCount()):
            print(self.table_report.item(i, 0).checkState())
            if self.table_report.item(i, 0).checkState() == QtCore.Qt.Checked:
                flag_select=True
        if not flag_select:
            self.show_mesagges(self.label_notif,text=texts.MESSAGES['one_least'][self.language],level=2)
            return


        # for i in range(self.table_report.rowCount()):
            
        if self.copy_flag:
            for i in range(self.table_report.rowCount()):
                self.progressBar.setValue(0)
                
                if self.table_report.item(i, 0).checkState() == QtCore.Qt.Checked:
                    # directory=self.table_report.item(i, 0).text() # if specesfic id
                    directory =(self.table_report.item(i, 10).text()).split("\\")[-1]
                    directory = os.path.split(directory)[-1]
                    dir=os.path.join(self.parent_dir, directory)
                    print(dir)
                    if not os.path.exists(dir):
                        os.mkdir(dir)
                    image_dir=os.path.join(dir, 'Images')
                    if not os.path.exists(image_dir):
                        os.mkdir(image_dir)
                    text_address=os.path.join(dir, directory)+'.txt'    
                    
                    text=self.set_details(i)

                    self.create_text(text_address,text)

                    print('text',self.table_report.item(i, 10).text())

                    if self.table_report.item(i, 1).text()=='Available':
                        self.progressBar.setValue(0)
                        self.label_3.setText('Copy: ')
                        self.label_4.setText(self.table_report.item(i, 10).text())
                        
                        # self.copytree(src=self.table_report.item(i, 10).text(),dst=image_dir)
                        threading.Thread(target=self.copytree,args=(self.table_report.item(i, 10).text(),image_dir)).start()
                        # self.progressBar.setValue(100)
                        
                        # cv2.waitKey(200)
                        
                    else:

                        self.show_mesagges(self.label_notif,text=texts.MESSAGES['no_image'][self.language],level=2)

                


    def set_details(self,row_number):
        text=[]
        for col in range(10):
            text.append(self.hh_Labels[col])
            text.append(':')
            text.append(self.table_report.item(row_number, col).text())
            # text.append('\n')
        # print(text)
        text=self.listToString(text)

        return text

    def listToString(self,s): 
        
        # initialize an empty string
        str1 = "" 
        x=0
        
        # traverse in the string  
        for ele in s: 
            x+=1
            str1 += ele  
            str1 +=' '
            if x%3==0:
                str1 +='\n'

        
        str1=str1[:-1]
        # return string  
        return str1 


    def create_text(self,text_address,text):
        with open(text_address, 'w') as f:
            f.write(str(text))

    def copy(self,source_folder,destination_folder):
        
        print(source_folder,destination_folder)

        
    def copytree(self,src, dst, symlinks=False, ignore=None):
        try:
            self.start_btn.setDisabled(True)
            print('src',src)
            for item in os.listdir(src):
                print('item',item)
                s = os.path.join(src, item)
                d = os.path.join(dst, item)
                if os.path.isdir(s):
                    shutil.copytree(s, d, symlinks, ignore)
                else:
                    shutil.copy2(s, d)

            self.progressBar.setValue(100)
            self.start_btn.setDisabled(False)

            
        except:
            print('Error copy {} {}'.format(src,dst))
            self.start_btn.setDisabled(False)





        # directory = str(slab_id)
        # path = os.path.join(self.parent_dir, directory)


    def test(self):

        self.db = database.check_connection()

        rec = database.test()
        self.set_data(rec)









    def show_mesagges(self, label_name, text="", level=0, clearable=True, prefix=True):
        """
        this function is used to show input message in input label, also there is a message level determining the color of label, and a timer to clear meesage after a while

        Inputs:
            label_name: label element name to show the message in
            text: input message to show (in string)
            level: level of the message (in int), its a value betweem [0, 2] determining the bakground color of message label
            clearable: a boolean value determining whater to clear the message after timeout or not
            prefix: a boolean value determinign wheater to show the message prefix or not

        Returns: None
        """

        if text != "":
            if level == 0:
                label_name.setText(text)
                # label_name.setStyleSheet("color:{}".format(color))
            #
            if level == 1:
                if prefix:
                    label_name.setText(text)
                else:
                    label_name.setText(text)
                label_name.setStyleSheet(
                    "background-color: %s; color:white;"
                    % (colors_pallete.warning_yellow)
                )
            #
            if level >= 2:
                if prefix:
                    label_name.setText(text)
                else:
                    label_name.setText(text)
                label_name.setStyleSheet(
                    "background-color: %s; color:white;" % (colors_pallete.failed_red)
                )

            #
            if clearable:
                self.show_mesagges_thread_lock = True

                # timer to clear the message
                #print("show_mesagges_thread_lock True")
                QTimer.singleShot(5000, lambda: self.show_mesagges(label_name))

        else:
            label_name.setText(text)




    def fuc_cancel_copy(self):
        self.copy_flag=False




if __name__ == "__main__":
    app = QApplication()
    win = UI_backup_window()
    win.show()
    # win.test()
    sys.exit(app.exec())
