# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'eror_window.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys


from PyQt5.QtGui import *
from PyQt5.QtGui import *
from PyQt5.QtGui import *
import cv2
from pyqt5_plugins import *

from PySide6.QtCore import *
from PySide6.QtUiTools import loadUiType
from PySide6.QtWidgets import *
from PyQt5 import QtCore, QtGui, QtWidgets, QtSql
import sqlite3
from sqlite3 import Error



ui2, _ = loadUiType("manage _user_window_2.ui")


class UI_manage_user_window(QMainWindow, ui2):
    global widgets
    widgets_eror = ui2
    image_glob=0
    close_sign=0
    def __init__(self):
        super(UI_manage_user_window, self).__init__()
        self.setupUi(self)
        # Remove default frame
        flags = Qt.WindowFlags(Qt.FramelessWindowHint )
        self.pos_ = self.pos()
        self.setWindowFlags(flags)
        # self.setWindowFlags(flags)
        self.activate_()
        self.table()
        self.combo()

        self.lineEdit_2.setEchoMode(QLineEdit.Password)
        self.lineEdit_4.setEchoMode(QLineEdit.Password)
      #  self.show()

        self._old_pos = None

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self._old_pos = event.pos()

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self._old_pos = None

    def mouseMoveEvent(self, event):
        if not self._old_pos:
            return
        delta = event.pos() - self._old_pos
        self.move(self.pos() + delta)



    def combo(self):
        x=["Operator", "Admin", "DORSA"]
        self.comboBox.addItems(x)


    def table(self):
        conn=self.create_connection('settings.db')
        cur = conn.cursor()
        cur.execute('select * from login')
        self.records = cur.fetchall()
        self.table_remove_user.resizeColumnsToContents()
        self.table_remove_user.setColumnCount(3)
        self.table_remove_user.setRowCount(99)
        self.table_remove_user.verticalHeader().setVisible(True)
        self.table_remove_user.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        headers = ['ID', 'Name', 'Access_level']
        self.table_remove_user.setHorizontalHeaderLabels(headers)
        try:
            table_item = QTableWidgetItem()
            str1=[]
            for i in self.records:
                str1.append(i[0])  
        # str1.append(0)
        # print(str1)
            for row, string in enumerate(str1):
            #  print (row,string)
                table_item = QTableWidgetItem(str(string))
                #table_item.setData(Qt.DisplayRole, str(string))
                table_item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)
                table_item.setCheckState(Qt.CheckState.Unchecked)
                self.table_remove_user.setItem(row,0,table_item)
            self.table_remove_user.setRowCount(row+1)
        except:
            print('tabble empty')

    def read_data_table(self):
        row_count=self.table_remove_user.rowCount()
        col_count=self.table_remove_user.columnCount()

       # print(row_count,col_count)
        checked_list = []
        list=[]
        try:
            for i in range(self.table_remove_user.rowCount()):    
                if self.table_remove_user.item(i,0).checkState() == QtCore.Qt.Checked:
                #   checked_list.append(self.defect_table.item(i, 1))
                    list.append(i)

            
        #  print(checked_list)
        #  print(self.records)
        #  print(list)
            checked_list = []
            for i in range (len(list)):
                checked_list.append(self.records[list[i]][0])
            print(checked_list)
            self.deleteRecord(checked_list)
            self.table()
        except:
            print('asdw')
        
        return(checked_list)

    def deleteRecord(self,checked_list):
        for i in range(len(checked_list)):
            try:
                conn=self.create_connection('settings.db')
                cur = conn.cursor()
                # Deleting single record now
                sql_delete_query = """DELETE from login where ID = ?"""
                data=checked_list[i]
                cur.execute(sql_delete_query,(data,))
                conn.commit()
                print("Record deleted successfully ")
                cur.close()
                self.message_show_delete.setText('Record {} deleted successfully'.format(checked_list))
                self.message_show_delete.setStyleSheet("color:#357C3C")
                # cv2.waitKey(3000)
                self.message_show_delete.setText('')
            except sqlite3.Error as error:
                print("Failed to delete record from sqlite table", error)
                self.message_show_delete.setText('DataBase Eror')
                self.message_show_delete.setStyleSheet("color:rgb(255,0,0)")
                cv2.waitKey(3000)
                self.message_show_delete.setText('')                
            finally:
                if conn:
                    conn.close()
                    print("the sqlite connection is closed")
    def activate_(self):
        self.close_btn.clicked.connect(self.close_win)
        self.close_btn_2.clicked.connect(self.close_win)
        self.save_close_btn.clicked.connect(self.close_win)
        self.remove_btn.clicked.connect(self.read_data_table)
        self.add_btn.clicked.connect(self.add)
    def close_win(self):
        self.close_sign=1
        self.close()


    def create_connection(self,db_file):
        """ create a database connection to the SQLite database
            specified by db_file
        :param db_file: database file
        :return: Connection object or None
        """
        conn = None
        try:
            conn = sqlite3.connect(db_file)
            return conn
        except Error as e:
            print(e)
            self.eror_window(msg=' NO connection to database {}'.format(db_file),level=3)
    def add(self):
        id=self.lineEdit.text()
        name=self.lineEdit_3.text()
        password=self.lineEdit_2.text()
        re_password=self.lineEdit_4.text()
        access=self.comboBox.currentText()
        print('current',self.comboBox.currentText())
        # print( bool(str(password)==str(re_password)),str(self.get_ids!=NULL))
        if (self.get_ids(id)==True) & (bool(str(password)==str(re_password))==True) & (self.comboBox.currentText()=='Operator') :
            try:
                conn=self.create_connection('settings.db')
                cur = conn.cursor()
                # Deleting single record now
                sql_delete_query = ''' INSERT INTO login (ID,password,name,access)
                VALUES(?,?,?,?) '''
                data=(id,password,name,access)
                cur.execute(sql_delete_query,(data))
                conn.commit()
                print("Record Add successfully ")
                cur.close()
                self.show_message.setText('User Created Successfully')
                self.show_message.setStyleSheet("color:#357C3C")
                cv2.waitKey(3000)
                self.show_message.setText('')

            except sqlite3.Error as error:
                print("Failed to add record from sqlite table", error)
                self.show_message.setText('DataBase Eror')
                self.show_message.setStyleSheet("color:rgb(255,0,0)")
                cv2.waitKey(3000)
                self.show_message.setText('')
            finally:
                if conn:
                    conn.close()
                    print("the sqlite connection is closed")
        
        elif (self.get_ids(id)!=True):
            self.show_message.setText('Invalid UserID')
            self.show_message.setStyleSheet("color:rgb(255,0,0)")
            cv2.waitKey(3000)
            self.show_message.setText('')

 
        
        elif str(password)!=str(re_password):
            self.show_message.setText('Password Not Match')
            self.show_message.setStyleSheet("color:rgb(255,0,0)")
            cv2.waitKey(3000)
            self.show_message.setText('')

        elif self.comboBox.currentText()!='Operator':
            self.show_message.setText('Set Access Level Operator')
            self.show_message.setStyleSheet("color:rgb(255,0,0)")
            cv2.waitKey(3000)
            self.show_message.setText('')            

        self.table()

    def get_ids(self,name):
        try:
            ids_list=[]
            conn = sqlite3.connect('settings.db')
            cur = conn.cursor()
            cur.execute('select * from login')
            records = cur.fetchall()   
            # print(records)
            # for i in range(len(records)):
            #     ids_list.append(records[0][i])
            # print(ids_list)
            print('name',name)
            print('re', records[0][:])
            for i in range(len(records)):
                print('rec',records[i][0])
                if name == records[i][0]:
                    print('False')
                    return False
        except:
            print('eror')
            return False
        
        
        return True
  
if __name__ == "__main__":
    app = QApplication()
    win = UI_manage_user_window()
    win.show()
    sys.exit(app.exec())
